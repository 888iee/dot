#!/usr/bin/env bash

set -ou pipefail

OVERRIDE_FILE="$HOME/.config/hypr/monitor_override"
VERBOSE=0
FLAG=""

#############################################
# Logging
#############################################
log() {
  if [[ "$VERBOSE" -eq 1 ]]; then
    # Zeitstempel + Nachricht
    echo "[LOG] $1" >&2
  fi
}

#############################################
# Argumente parsen
#############################################
while [[ $# -gt 0 ]]; do
  case "$1" in
  --override)
    FLAG="override"
    ;;
  --use-override)
    FLAG="use-override"
    ;;
  -v | --verbose)
    VERBOSE=1
    ;;
  *)
    echo "Unbekanntes Argument: $1" >&2
    ;;
  esac
  shift
done

log "main: Start mit FLAG='$FLAG', VERBOSE=$VERBOSE"

#############################################
# Monitore einlesen
#############################################
read_monitors() {
  log "read_monitors: rufe 'hyprctl monitors' auf"

  mapfile -t outputs < <(
    hyprctl monitors |
      grep -Eo 'Monitor .* |at [[:digit:]]*x[[:digit:]]*' |
      paste - - |
      sort -n -k5 |
      cut -d' ' -f2
  )

  log "read_monitors: Gefundene Monitore (Reihenfolge): ${outputs[@]}"
  echo "Gefundene Monitore: ${outputs[@]}"
}

#############################################
# Auflösung eines Monitors holen
#############################################
get_resolution() {
  local mon="$1"
  log "get_resolution: suche Auflösung für Monitor '$mon'"

  # Debug: Roh-Ausgabe einmal ausgeben, falls nötig
  # (nur bei verbose)
  if [[ "$VERBOSE" -eq 1 ]]; then
    log "get_resolution: Ausschnitt von 'hyprctl monitors' für '$mon':"
    hyprctl monitors | awk -v m="$mon" '
            $0 ~ ("Monitor " m " ") { print; c=1; next }
            c && NF==0 { exit }
            c { print }
        ' >&2
  fi

  # Robuste Suche nach der Zeile mit 1920x1080@...
  local res_line
  res_line=$(hyprctl monitors | awk -v m="$mon" '
        $0 ~ ("Monitor " m " ") { found=1; next }
        found && $0 ~ /^[ \t]*[0-9]+x[0-9]+@/ {
            print $1; exit
        }
    ')

  log "get_resolution: gefundene Auflösungs-Zeile für '$mon': '$res_line'"

  if [[ -z "$res_line" ]]; then
    log "get_resolution: WARNUNG: keine Auflösung für '$mon' gefunden, setze 0x0"
    echo "0 0"
    return
  fi

  local w h
  w="${res_line%x*}"
  h="${res_line#*x}"
  h="${h%@*}"

  log "get_resolution: parsed width=$w height=$h für '$mon'"
  echo "$w $h"
}

#############################################
# Automatische Erkennung des Hauptmonitors
#############################################
auto_detect_main() {
  local count=${#outputs[@]}
  log "auto_detect_main: Anzahl Monitore: $count, Liste: ${outputs[@]}"

  # Fall 1: Nur eDP-1
  if [[ $count -eq 1 && "${outputs[0]}" == "eDP-1" ]]; then
    log "auto_detect_main: Fall 1 (nur eDP-1) -> Hauptmonitor=eDP-1"
    echo "eDP-1"
    return
  fi

  # Fall 2: eDP-1 + 1 externer
  if [[ $count -eq 2 && "${outputs[0]}" == "eDP-1" ]]; then
    log "auto_detect_main: Fall 2 (eDP-1 + 1 externer) -> Hauptmonitor=eDP-1"
    echo "eDP-1"
    return
  fi

  # Fall 4: Nur 1 externer (Laptop zugeklappt)
  if [[ $count -eq 1 && "${outputs[0]}" != "eDP-1" ]]; then
    log "auto_detect_main: Fall 4 (nur 1 externer) -> Hauptmonitor=${outputs[0]}"
    echo "${outputs[0]}"
    return
  fi

  # Fall 3: eDP-1 + 2 externe
  if [[ $count -eq 3 ]]; then
    local ext1="${outputs[1]}"
    local ext2="${outputs[2]}"

    log "auto_detect_main: Fall 3 (eDP-1 + 2 externe): ext1=$ext1 ext2=$ext2"

    read w1 h1 <<<"$(get_resolution "$ext1")"
    read w2 h2 <<<"$(get_resolution "$ext2")"

    local area1=$((w1 * h1))
    local area2=$((w2 * h2))

    log "auto_detect_main: $ext1 -> ${w1}x${h1}, area1=$area1"
    log "auto_detect_main: $ext2 -> ${w2}x${h2}, area2=$area2"

    if ((area1 > area2)); then
      log "auto_detect_main: area1 > area2 -> Hauptmonitor=$ext1"
      echo "$ext1"
    elif ((area2 > area1)); then
      log "auto_detect_main: area2 > area1 -> Hauptmonitor=$ext2"
      echo "$ext2"
    else
      log "auto_detect_main: gleiche Fläche -> erster externer ($ext1) als Hauptmonitor"
      echo "$ext1"
    fi
    return
  fi

  log "auto_detect_main: Fallback -> Hauptmonitor=eDP-1"
  echo "eDP-1"
}

#############################################
# Zenity-Dialog für Override
#############################################
zenity_choose_monitor() {
  local auto="$1"
  log "zenity_choose_monitor: auto vorgeschlagen=$auto"

  local args=(
    --list
    --radiolist
    --title="Hauptmonitor auswählen"
    --text="Bitte wähle den Hauptmonitor:"
    --column="Auswahl"
    --column="Monitor"
  )

  for mon in "${outputs[@]}"; do
    if [[ "$mon" == "$auto" ]]; then
      args+=(TRUE "$mon")
    else
      args+=(FALSE "$mon")
    fi
  done

  zenity "${args[@]}"
}

#############################################
# Override speichern
#############################################
save_override() {
  mkdir -p "$(dirname "$OVERRIDE_FILE")"
  echo "$1" >"$OVERRIDE_FILE"
  log "save_override: Override gespeichert: $1 in $OVERRIDE_FILE"
  echo "Override gespeichert: $1"
}

#############################################
# Override laden
#############################################
load_override() {
  if [[ -f "$OVERRIDE_FILE" ]]; then
    local v
    v=$(<"$OVERRIDE_FILE")
    log "load_override: gelesen: '$v' aus $OVERRIDE_FILE"
    echo "$v"
  else
    log "load_override: keine Override-Datei gefunden"
  fi
}

#############################################
# Workspaces zuweisen (Platzhalter)
#############################################
assign_workspaces() {
  local main="$1"
  log "assign_workspaces: Starte Workspace-Zuweisung für Hauptmonitor '$main'"

  local tmp_file="/tmp/workspace.conf"
  : >"$tmp_file"
  # Sekundäre Monitore bestimmen
  local secondaries=()
  for mon in "${outputs[@]}"; do
    if [[ "$mon" != "$main" ]]; then
      secondaries+=("$mon")
    fi
  done

  log "assign_workspaces: Sekundäre Monitore: ${secondaries[*]}"

  #############################################
  # 1. Hauptmonitor: Workspaces 1–7
  #############################################
  log "assign_workspaces: Hauptmonitor '$main' bekommt Workspaces 1–8"

  for ws in {2..8}; do
    local line
    if [[ "$ws" -eq 2 ]]; then
      # default + persistent
      line="workspace = $ws, monitor:$main, default:1, persistent:1"
      log "assign_workspaces:   WS $ws → default=1, persistent=1"
    else
      # nicht persistent, nicht default
      line="workspace = $ws, monitor:$main, default:0, persistent:0"
      log "assign_workspaces:   WS $ws → default=0, persistent=0"
    fi
    echo "$line" >>"$tmp_file"
  done

  #############################################
  # 2. Sekundäre Monitore: Workspaces 11–20
  #############################################
  local sec_count=${#secondaries[@]}
  if ((sec_count > 0)); then
    local start=11
    local end=20
    local total=$((end - start + 1))
    local per=$((total / sec_count))

    log "assign_workspaces: Verteile Workspaces 11–20 auf $sec_count sekundäre Monitore (je $per WS)"

    log "${secondaries[@]}"
    local idx=0
    for mon in "${secondaries[@]}"; do
      local s=$((start + idx * per))
      local e=$((s + per - 1))

      log "assign_workspaces:   Monitor '$mon' bekommt Workspaces $s–$e"
      log "${secondaries[@]}"
      local first=1
      for ws in $(seq "$s" "$e"); do
        local line
        if [[ $first -eq 1 ]]; then
          # erster WS → persistent, aber nicht default
          line="workspace = $ws, monitor:$mon, default:0, persistent:1"
          log "assign_workspaces:     WS $ws → default=0, persistent=1"
          first=0
        else
          line="workspace = $ws, monitor:$mon, default:0, persistent:0"
          log "assign_workspaces:     WS $ws → default=0, persistent=0"
        fi
        echo "$line" >>"$tmp_file"
      done
      log "$idx $mon $ws"
      ((idx++))
      log "$idx $mon $ws"
    done
  fi

  #############################################
  # 3. Sonderfall: Workspaces 8, 9, 0
  #############################################
  local special_monitor="$main"
  if printf '%s\n' "${outputs[@]}" | grep -q "^eDP-1$"; then
    special_monitor="eDP-1"
  fi

  log "assign_workspaces: Sonder-Workspaces 9, 0 → Monitor '$special_monitor'"

  for ws in 9 10; do
    local line="workspace = $ws, monitor:$special_monitor, default:0, persistent:1"
    log "assign_workspaces:   WS $ws → default=0, persistent=1"
    echo "$line" >>"$tmp_file"
  done

  #############################################
  # 4. Datei nach $HOME kopieren
  #############################################
  cp "$tmp_file" "$HOME/.config/hypr/workspaces.conf"
  log "assign_workspaces: workspace.conf nach $HOME/workspace.conf kopiert"

  echo "Hauptmonitor: $main"
  echo "Workspaces wurden generiert."
}

#############################################
# Hauptlogik
#############################################
read_monitors

case "$FLAG" in
override)
  log "main: FLAG=override -> Zenity-Dialog"
  auto_main=$(auto_detect_main)
  log "main: auto_detect_main -> $auto_main"
  chosen=$(zenity_choose_monitor "$auto_main")
  [[ -z "$chosen" ]] && {
    log "main: Zenity abgebrochen"
    echo "Abgebrochen."
    exit 1
  }
  log "main: Zenity Auswahl -> $chosen"
  save_override "$chosen"
  exit 0
  ;;

use-override)
  log "main: FLAG=use-override -> versuche Override zu laden"
  override=$(load_override)
  if printf '%s\n' "${outputs[@]}" | grep -q "^$override$"; then
    log "main: Override '$override' ist in outputs vorhanden -> benutze als Hauptmonitor"
    main_monitor="$override"
  else
    log "main: Override '$override' ungültig oder nicht vorhanden -> benutze Automatik"
    main_monitor=$(auto_detect_main)
  fi
  ;;

*)
  log "main: kein FLAG -> benutze Automatik"
  main_monitor=$(auto_detect_main)
  ;;
esac
echo "Monitore: ${outputs[@]}"

log "main: finaler Hauptmonitor=$main_monitor"
assign_workspaces "$main_monitor"
